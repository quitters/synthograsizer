{
  "promptTemplate": "A fractal tree with {{branches}} branches, angle {{angle}}, length reduction {{length_reduction}}, min branch size {{min_size}}, color mode {{color_mode}}.",
  "variables": [
    { "name": "Branches", "feature_name": "branches", "values": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"] },
    { "name": "Angle", "feature_name": "angle", "values": ["0", "15", "30", "45", "60", "75", "90", "105", "120", "135", "150", "165", "180"] },
    { "name": "Length Reduction", "feature_name": "length_reduction", "values": ["0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1"] },
    { "name": "Min Size", "feature_name": "min_size", "values": ["2", "4", "8", "16", "24", "32", "48", "64", "80", "96", "112", "128"] },
    { "name": "Color Mode", "feature_name": "color_mode", "values": ["spring", "summer", "autumn", "winter"] }
  ],
  "p5_input": {
    "code": "// SYNTHOGRASIZER P5.JS EXAMPLE: Recursive Fractal Tree\n// \n// This example demonstrates recursion to create a fractal tree\n// where the branches split and become smaller with depth.\n// It showcases:\n// - Recursive drawing techniques\n// - Using the p5.js console for debugging\n// - Advanced color transitions with HSB color mode\n// - Dynamic parameter adjustment using knob values\n//\n// REQUIRED VARIABLES:\n// - \"branches\" for controlling the number of branches per split (2-5)\n// - \"angle\" for controlling the angle between branches\n// - \"length_reduction\" for controlling how much each branch shrinks\n// - \"min_size\" for setting the minimum size of branches before stopping\n// - \"color_mode\" for switching between color styles\n\n// Keep track of animation/generation parameters\nlet startLength = 120;\nlet startThickness = 10;\nlet maxDepth = 0;\nlet startColor, endColor;\nlet drawMode = 'static'; // 'static', 'animated', 'wind'\nlet windAngle = 0;\nlet windSpeed = 0.02;\nlet windStrength = 0.2;\n\np.setup = function() {\n  p.createCanvas(500, 500).parent(p5Output);\n  p.angleMode(p.DEGREES);\n  // p.noLoop(); // Removed for interactivity\n  p.colorMode(p.HSB, 360, 100, 100, 1);\n  p.strokeCap(p.ROUND);\n  \n  // Set default colors\n  startColor = p.color(30, 80, 40);\n  endColor = p.color(120, 90, 70);\n  \n  p.print(\"Fractal Tree initialized! Use the console to see debug info.\");\n  p.print(\"Check out the different branches, angles, and colors!\");\n};\n\np.draw = function() {\n  p.background(220);\n  \n  // Get variables from Synthograsizer\n  const branchesVar = p.getSynthVar('branches') || 2;\n  const angleVar = p.getSynthVar('angle') || 30;\n  const lengthReductionVar = p.getSynthVar('length_reduction') || 0.7;\n  const minSizeVar = p.getSynthVar('min_size') || 10;\n  const colorModeVar = p.getSynthVar('color_mode') || 'autumn';\n  \n  // Process variables according to type (Mode A = string, Mode B = number)\n  let branches = 2;\n  if (typeof branchesVar === 'number') {\n    branches = p.constrain(Math.floor(p.map(branchesVar, -1, 2, 2, 5)), 2, 5);\n  } else if (typeof branchesVar === 'string') {\n    branches = p.constrain(parseInt(branchesVar) || 2, 2, 5);\n  }\n  \n  let angle = 30;\n  if (typeof angleVar === 'number') {\n    angle = p.map(angleVar, -1, 2, 10, 50);\n  } else if (typeof angleVar === 'string') {\n    angle = parseFloat(angleVar) || 30;\n  }\n  \n  let lengthReduction = 0.7;\n  if (typeof lengthReductionVar === 'number') {\n    lengthReduction = p.map(lengthReductionVar, -1, 2, 0.5, 0.85);\n  } else if (typeof lengthReductionVar === 'string') {\n    lengthReduction = parseFloat(lengthReductionVar) || 0.7;\n  }\n  \n  let minSize = 10;\n  if (typeof minSizeVar === 'number') {\n    minSize = p.map(minSizeVar, -1, 2, 2, 20);\n  } else if (typeof minSizeVar === 'string') {\n    minSize = parseFloat(minSizeVar) || 10;\n  }\n  \n  // Set color scheme based on selection\n  if (typeof colorModeVar === 'string') {\n    switch(colorModeVar.toLowerCase()) {\n      case 'spring':\n        startColor = p.color(90, 30, 90);   // Light green\n        endColor = p.color(120, 80, 80);    // Bright green\n        break;\n      case 'summer':\n        startColor = p.color(60, 70, 90);   // Yellow-green\n        endColor = p.color(200, 60, 90);    // Sky blue\n        break;\n      case 'autumn':\n        startColor = p.color(30, 80, 60);   // Brown/Orange\n        endColor = p.color(50, 90, 100);    // Gold/Yellow\n        break;\n      case 'winter':\n        startColor = p.color(200, 20, 80);  // Cool blue\n        endColor = p.color(220, 10, 100);   // Pale blue/white\n        break;\n      default:\n        startColor = p.color(120, 80, 80);  // Default green\n        endColor = p.color(200, 60, 90);    // Default blue\n    }\n  }\n  \n  // Draw the tree\n  p.push();\n  p.translate(p.width / 2, p.height);\n  drawBranch(startLength, startThickness, branches, angle, lengthReduction, minSize, 0);\n  p.pop();\n};\n\n// Recursive function to draw branches\nfunction drawBranch(len, thickness, branches, angle, reduction, minSize, depth) {\n  // Base case: stop drawing if branch is too small\n  if (len < minSize) return;\n  \n  // Draw current branch\n  p.strokeWeight(thickness);\n  p.stroke(lerpColor(startColor, endColor, depth / maxDepth));\n  p.line(0, 0, 0, -len);\n  \n  // Move to end of current branch\n  p.translate(0, -len);\n  \n  // Draw child branches\n  for (let i = 0; i < branches; i++) {\n    p.push();\n    p.rotate(angle * (i - (branches - 1) / 2));\n    drawBranch(len * reduction, thickness * reduction, branches, angle, reduction, minSize, depth + 1);\n    p.pop();\n  }\n}\n\n// Helper function to interpolate between HSB colors\nfunction lerpColor(c1, c2, amt) {\n  let h1 = p.hue(c1);\n  let s1 = p.saturation(c1);\n  let b1 = p.brightness(c1);\n  let h2 = p.hue(c2);\n  let s2 = p.saturation(c2);\n  let b2 = p.brightness(c2);\n  \n  let h = p.lerp(h1, h2, amt);\n  let s = p.lerp(s1, s2, amt);\n  let b = p.lerp(b1, b2, amt);\n  \n  return p.color(h, s, b);\n}"
  }
}
