{
  "promptTemplate": "A portrait of a person with {{head_shape}} head shape, {{skin_tone}} skin, {{eye_color}} eyes with {{eye_shape}} shape, {{eyebrow_style}} eyebrows, {{hair_style}} {{hair_color}} hair, {{nose_shape}} nose, {{mouth_shape}} mouth, {{ear_size}} ears, {{neck_width}} neck, {{facial_hair}} facial hair, and {{accessories}}",
  "variables": [
    {
      "name": "Head Shape",
      "feature_name": "head_shape",
      "values": [
        "oval",
        "round",
        "square",
        "heart",
        "diamond",
        "rectangular"
      ]
    },
    {
      "name": "Skin Tone",
      "feature_name": "skin_tone",
      "values": [
        "pale",
        "light",
        "medium",
        "tan",
        "brown",
        "dark"
      ]
    },
    {
      "name": "Eye Color",
      "feature_name": "eye_color",
      "values": [
        "brown",
        "hazel",
        "green",
        "blue",
        "gray",
        "amber"
      ]
    },
    {
      "name": "Eye Shape",
      "feature_name": "eye_shape",
      "values": [
        "almond",
        "round",
        "hooded",
        "narrow",
        "wide",
        "upturned"
      ]
    },
    {
      "name": "Eyebrow Style",
      "feature_name": "eyebrow_style",
      "values": [
        "arched",
        "straight",
        "thick",
        "thin",
        "bushy",
        "angled"
      ]
    },
    {
      "name": "Hair Style",
      "feature_name": "hair_style",
      "values": [
        "short",
        "long",
        "wavy",
        "curly",
        "bald",
        "straight"
      ]
    },
    {
      "name": "Hair Color",
      "feature_name": "hair_color",
      "values": [
        "black",
        "brown",
        "blonde",
        "red",
        "gray",
        "white"
      ]
    },
    {
      "name": "Nose Shape",
      "feature_name": "nose_shape",
      "values": [
        "straight",
        "button",
        "upturned",
        "broad",
        "narrow",
        "long"
      ]
    },
    {
      "name": "Mouth Shape",
      "feature_name": "mouth_shape",
      "values": [
        "full",
        "thin",
        "wide",
        "small",
        "heart",
        "curved"
      ]
    },
    {
      "name": "Ear Size",
      "feature_name": "ear_size",
      "values": [
        "tiny",
        "small",
        "medium",
        "large",
        "prominent",
        "hidden"
      ]
    },
    {
      "name": "Neck Width",
      "feature_name": "neck_width",
      "values": [
        "very-thin",
        "thin",
        "average",
        "thick",
        "wide",
        "muscular"
      ]
    },
    {
      "name": "Facial Hair",
      "feature_name": "facial_hair",
      "values": [
        "none",
        "mustache",
        "goatee",
        "full-beard",
        "stubble",
        "sideburns"
      ]
    },
    {
      "name": "Accessories",
      "feature_name": "accessories",
      "values": [
        "none",
        "glasses",
        "sunglasses",
        "earrings",
        "hat",
        "both-glasses-earrings"
      ]
    }
  ],
  "p5_input": {
    "code": "// SYNTHOGRASIZER P5.JS: Merged & Enhanced Generative Face Creator\n//\n// This sketch generates animated, randomized faces based on 13 distinct traits.\n// Combines robust structure with enhanced aesthetic features.\n//\n// REQUIRED HTML VARIABLE:\n// - p5Output: A string variable defined in your HTML scope, holding the ID\n//             of the DOM element where the canvas should be placed.\n\n// Animation control\nlet isPaused = false;\nlet frameCounter = 0;\n\n// UI Button properties\nlet playButton, pauseButton, randomizeButton;\nlet buttonSize = 80;\nlet buttonMargin = 10;\n\n// Face parameters\nlet faceParams = {\n  head_shape: 'oval', skin_tone: 'medium', eye_color: 'brown', eye_shape: 'almond',\n  eyebrow_style: 'arched', hair_style: 'short', hair_color: 'brown', nose_shape: 'straight',\n  mouth_shape: 'full', ear_size: 'medium', neck_width: 'average', facial_hair: 'none',\n  accessories: 'none'\n};\n\n// Available options\nconst traitOptions = {\n  head_shape: ['oval', 'round', 'square', 'heart', 'diamond', 'rectangular'],\n  skin_tone: ['pale', 'light', 'medium', 'tan', 'brown', 'dark'],\n  eye_color: ['brown', 'hazel', 'green', 'blue', 'gray', 'amber'],\n  eye_shape: ['almond', 'round', 'hooded', 'narrow', 'wide', 'upturned'],\n  eyebrow_style: ['arched', 'straight', 'thick', 'thin', 'bushy', 'angled'],\n  hair_style: ['short', 'long', 'wavy', 'curly', 'bald', 'straight'],\n  hair_color: ['black', 'brown', 'blonde', 'red', 'gray', 'white'],\n  nose_shape: ['straight', 'button', 'upturned', 'broad', 'narrow', 'long'],\n  mouth_shape: ['full', 'thin', 'wide', 'small', 'heart', 'curved'],\n  ear_size: ['tiny', 'small', 'medium', 'large', 'prominent', 'hidden'],\n  neck_width: ['very-thin', 'thin', 'average', 'thick', 'wide', 'muscular'],\n  facial_hair: ['none', 'mustache', 'goatee', 'full-beard', 'stubble', 'sideburns'],\n  accessories: ['none', 'glasses', 'sunglasses', 'earrings', 'hat', 'both-glasses-earrings']\n};\n\np.setup = function() {\n  if (typeof p5Output === 'string' && document.getElementById(p5Output)) {\n    p.createCanvas(512, 640).parent(p5Output);\n  } else {\n    console.warn(`'p5Output' (value: ${typeof p5Output !== 'undefined' ? p5Output : 'undefined'}) is not a valid ID of an existing DOM element. Canvas will be appended to body.`);\n    p.createCanvas(512, 640);\n  }\n  \n  p.frameRate(5);\n  p.rectMode(p.CENTER); p.ellipseMode(p.CENTER); p.textAlign(p.CENTER, p.CENTER);\n  p.strokeJoin(p.ROUND); p.strokeCap(p.ROUND);\n  \n  pauseButton = { x: buttonMargin, y: buttonMargin, w: buttonSize, h: 40, label: 'PAUSE' };\n  playButton = { x: buttonMargin, y: buttonMargin, w: buttonSize, h: 40, label: 'PLAY' };\n  randomizeButton = { x: p.width - buttonMargin - buttonSize, y: buttonMargin, w: buttonSize, h: 40, label: 'RANDOM' };\n  \n  if (typeof p.getSynthVar === 'undefined') {\n    p.getSynthVar = function(traitName) { return undefined; };\n    console.warn(\"p.getSynthVar was undefined. Placeholder function created.\");\n  }\n  randomizeFace();\n};\n\np.draw = function() {\n  // Gradient background (from V_User)\n  for(let i = 0; i <= p.height; i++) {\n    let inter = p.map(i, 0, p.height, 0, 1);\n    let c = p.lerpColor(p.color(200, 200, 210), p.color(140, 140, 150), inter);\n    p.stroke(c);\n    p.line(0, i, p.width, i);\n  }\n  \n  updateFromSynthograsizer();\n  \n  if (!isPaused) {\n    frameCounter++;\n    if (frameCounter >= 1) { randomizeFace(); frameCounter = 0; }\n  }\n  drawFace();\n  drawUIButtons();\n};\n\np.mousePressed = function() {\n  let btn = isPaused ? playButton : pauseButton;\n  if (p.mouseX > btn.x && p.mouseX < btn.x + btn.w && p.mouseY > btn.y && p.mouseY < btn.y + btn.h) {\n    if (isPaused) p.resumeAnimation(); else p.pauseAnimation();\n  }\n  if (p.mouseX > randomizeButton.x && p.mouseX < randomizeButton.x + randomizeButton.w &&\n      p.mouseY > randomizeButton.y && p.mouseY < randomizeButton.y + randomizeButton.h) {\n    randomizeFace(); if(isPaused) p.redraw();\n  }\n};\n\nfunction drawUIButtons() {\n  p.push();\n  p.textAlign(p.CENTER, p.CENTER); p.textSize(14); p.strokeWeight(2);\n  let btn = isPaused ? playButton : pauseButton;\n  p.fill(isPaused ? 50 : 200, isPaused ? 200 : 50, 50); p.stroke(0);\n  p.rect(btn.x + btn.w/2, btn.y + btn.h/2, btn.w, btn.h, 5);\n  p.fill(255); p.noStroke(); p.text(btn.label, btn.x + btn.w/2, btn.y + btn.h/2);\n  \n  p.fill(50, 50, 200); p.stroke(0);\n  p.rect(randomizeButton.x + randomizeButton.w/2, randomizeButton.y + randomizeButton.h/2, randomizeButton.w, randomizeButton.h, 5);\n  p.fill(255); p.noStroke(); p.text(randomizeButton.label, randomizeButton.x + randomizeButton.w/2, randomizeButton.y + randomizeButton.h/2);\n  \n  p.fill(255); p.stroke(0); p.strokeWeight(1); p.textSize(16);\n  p.text(isPaused ? 'MANUAL MODE' : 'AUTO MODE', p.width/2, 30);\n  p.pop();\n}\n\nfunction updateFromSynthograsizer() {\n  for (let trait in faceParams) {\n    if (typeof p.getSynthVar === 'function') {\n        let value = p.getSynthVar(trait);\n        if (value !== undefined && typeof value === 'string') {\n          if (traitOptions[trait] && traitOptions[trait].includes(value)) faceParams[trait] = value;\n        } else if (value !== undefined && typeof value === 'number') {\n          let idx = p.constrain(Math.floor(p.map(value, -1, 2, 0, traitOptions[trait].length)), 0, traitOptions[trait].length - 1);\n          faceParams[trait] = traitOptions[trait][idx];\n        }\n    }\n  }\n}\n\nfunction drawFace() {\n  p.push();\n  p.translate(p.width / 2, p.height / 2);\n  p.scale(2.5); \n  // Note: Generic shadow p.ellipse(5, 105, 140, 40) from V_User removed,\n  // as V_Mine's drawNeck provides a more specific chin shadow.\n  \n  drawHairBack();   // Merged: V_User for most styles, V_Mine for specific (short) if applicable\n  drawNeck();\n  drawHead();       // Retained from V_Mine\n  drawEars();       // Borrowed from V_User\n  drawEyes();       // Borrowed from V_User (as it's more detailed)\n  drawNose();       // Retained from V_Mine\n  drawMouth();      // Borrowed from V_User (as it's more detailed)\n  drawEyebrows();   // Retained from V_Mine\n  drawHairFront();  // Merged: V_User for most styles, V_Mine for 'short'\n  drawFacialHair(); // Borrowed from V_User (full-beard modified)\n  drawAccessories();// Borrowed from V_User (as it's more detailed)\n  p.pop();\n}\n\n// --- Color Mapping Functions (from V_User for enhanced tones) ---\nfunction getSkinColor(tone) {\n  const colors = {\n    'pale': p.color(255, 233, 218), 'light': p.color(255, 215, 185),\n    'medium': p.color(235, 190, 150), 'tan': p.color(210, 165, 125),\n    'brown': p.color(165, 115, 85), 'dark': p.color(110, 75, 55)\n  };\n  return colors[tone] || colors['medium'];\n}\nfunction getEyeColor(color) {\n  const colors = {\n    'brown': p.color(101, 67, 33), 'hazel': p.color(150, 120, 80),\n    'green': p.color(70, 130, 70), 'blue': p.color(70, 130, 200),\n    'gray': p.color(100, 110, 120), 'amber': p.color(255, 191, 0)\n  };\n  return colors[color] || colors['brown'];\n}\nfunction getHairColor(color) {\n  const colors = {\n    'black': p.color(25, 25, 30), 'brown': p.color(101, 67, 33),\n    'blonde': p.color(240, 210, 110), 'red': p.color(165, 65, 42),\n    'gray': p.color(140, 145, 150), 'white': p.color(230, 235, 240)\n  };\n  return colors[color] || colors['brown'];\n}\n\n// --- Retained Drawing Functions from V_Mine ---\nfunction drawHead() { // Retained from V_Mine\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  p.stroke(0); p.strokeWeight(2); p.fill(skinColor); // V_Mine used strokeWeight 2\n\n  switch(faceParams.head_shape) {\n    case 'oval': p.ellipse(0, 0, 150, 200); break;\n    case 'round': p.ellipse(0, 0, 175, 175); break;\n    case 'square':\n      p.beginShape();\n      p.vertex(-75, -87.5); p.bezierVertex(-80, -87.5, -80, 87.5, -75, 87.5);\n      p.bezierVertex(-75, 92.5, 75, 92.5, 75, 87.5); p.bezierVertex(80, 87.5, 80, -87.5, 75, -87.5);\n      p.bezierVertex(75, -92.5, -75, -92.5, -75, -87.5); p.endShape(p.CLOSE);\n      break;\n    case 'heart':\n      p.beginShape(); p.vertex(0, -85); p.bezierVertex(-75, -100, -90, -50, -75, 0);\n      p.bezierVertex(-75, 50, -50, 85, 0, 100); p.bezierVertex(50, 85, 75, 50, 75, 0);\n      p.bezierVertex(90, -50, 75, -100, 0, -85); p.endShape(p.CLOSE);\n      break;\n    case 'diamond':\n      p.beginShape(); p.vertex(0, -100); p.vertex(-75, 0); p.vertex(0, 100); p.vertex(75, 0); p.endShape(p.CLOSE);\n      break;\n    case 'rectangular':\n      p.beginShape(); p.vertex(-70, -100); p.bezierVertex(-75, -100, -75, 100, -70, 100);\n      p.bezierVertex(-70, 105, 70, 105, 70, 100); p.bezierVertex(75, 100, 75, -100, 70, -100);\n      p.bezierVertex(70, -105, -70, -105, -70, -100); p.endShape(p.CLOSE);\n      break;\n    default: p.ellipse(0, 0, 150, 200);\n  }\n}\n\nfunction drawNeck() { // Retained from V_Mine (includes chin shadow)\n  let neckWidths = { 'very-thin': 30, 'thin': 40, 'average': 50, 'thick': 60, 'wide': 70, 'muscular': 65 };\n  let width = neckWidths[faceParams.neck_width] || 50;\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  let shadowColor = p.lerpColor(skinColor, p.color(0), 0.15);\n  p.stroke(0); p.strokeWeight(2); p.fill(skinColor);\n  let neckTopY = 85; let neckBottomY = 150; let topWidth = width * 0.9; let bottomWidth = width;\n  p.beginShape(); p.vertex(-topWidth / 2, neckTopY);\n  p.bezierVertex(-topWidth / 2, neckTopY + 20, -bottomWidth / 2, neckBottomY - 20, -bottomWidth / 2, neckBottomY);\n  p.vertex(bottomWidth / 2, neckBottomY);\n  p.bezierVertex(bottomWidth / 2, neckBottomY - 20, topWidth / 2, neckTopY + 20, topWidth / 2, neckTopY);\n  p.endShape(p.CLOSE);\n  p.noStroke(); p.fill(shadowColor);\n  let shadowWidthFactor = 1;\n  if (faceParams.head_shape === 'square' || faceParams.head_shape === 'rectangular') shadowWidthFactor = 1.1;\n  else if (faceParams.head_shape === 'round') shadowWidthFactor = 1.2;\n  p.arc(0, neckTopY + 5, topWidth * shadowWidthFactor, 30 + (shadowWidthFactor-1)*20, 0, p.PI);\n\n  // Muscle definition from V_User (integrated here if neck is muscular)\n  if (faceParams.neck_width === 'muscular') {\n    p.stroke(p.lerpColor(skinColor, p.color(0), 0.1)); // Softer stroke color\n    p.strokeWeight(1); // Thinner stroke for detail\n    p.noFill();\n    // Simplified sternocleidomastoid indication\n    p.line(-width/3.5, neckTopY + 5, -width/5, neckBottomY - 20);\n    p.line(width/3.5, neckTopY + 5, width/5, neckBottomY - 20);\n  }\n}\n\nfunction drawNose() { // Retained from V_Mine\n  p.stroke(0); p.strokeWeight(1.5);\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  let noseShadowColor = p.lerpColor(skinColor, p.color(0), 0.2);\n  let noseHighlightColor = p.lerpColor(skinColor, p.color(255), 0.1);\n  let noseY = 5;\n  switch(faceParams.nose_shape) {\n    case 'straight':\n      p.stroke(p.lerpColor(skinColor, p.color(0), 0.3)); p.line(0, -10 + noseY, 0, 0 + noseY);\n      p.stroke(0); p.noFill(); p.beginShape(); p.vertex(-8, 10 + noseY);\n      p.bezierVertex(-5, 16 + noseY, 5, 16 + noseY, 8, 10 + noseY); p.endShape();\n      p.fill(noseShadowColor); p.noStroke(); p.ellipse(-4, 9 + noseY, 3.5, 3); p.ellipse(4, 9 + noseY, 3.5, 3);\n      break;\n    case 'button':\n      p.fill(skinColor); p.stroke(0); p.strokeWeight(1); p.ellipse(0, 7 + noseY, 20, 16);\n      p.fill(noseShadowColor); p.noStroke(); p.ellipse(-4.5, 11 + noseY, 4, 3.5); p.ellipse(4.5, 11 + noseY, 4, 3.5);\n      p.fill(noseHighlightColor); p.ellipse(0, 4 + noseY, 6, 4);\n      break;\n    // V_Mine didn't have these, V_User did. Adding them here for completeness based on V_User style:\n    case 'upturned': // From V_User, adapted slightly\n      p.stroke(0); p.strokeWeight(1); p.noFill();\n      p.arc(0, 5 + noseY, 18, 15, p.PI -0.7, p.TWO_PI + 0.7); // Main curve\n      p.fill(noseShadowColor); p.noStroke();\n      p.ellipse(-5, 8 + noseY, 4, 3); // Left nostril\n      p.ellipse(5, 8 + noseY, 4, 3);  // Right nostril\n      break;\n    case 'broad': // From V_User, adapted slightly\n        p.stroke(0); p.strokeWeight(1); p.noFill();\n        p.line(-5, -10 + noseY, -5, 10 + noseY); // Left bridge line\n        p.line(5, -10 + noseY, 5, 10 + noseY);  // Right bridge line\n        p.arc(0, 10 + noseY, 24, 12, 0, p.PI); // Bottom curve of nose\n        p.fill(noseShadowColor); p.noStroke();\n        p.ellipse(-7, 9 + noseY, 5, 3.5); // Left nostril\n        p.ellipse(7, 9 + noseY, 5, 3.5);  // Right nostril\n        break;\n    case 'narrow': // From V_User, adapted slightly\n        p.stroke(0); p.strokeWeight(1); p.noFill();\n        p.line(0, -12.5 + noseY, 0, 8 + noseY); // Center bridge line\n        p.arc(0, 8 + noseY, 10, 8, 0, p.PI);    // Bottom curve of nose\n        p.fill(noseShadowColor); p.noStroke();\n        p.ellipse(-2.5, 7 + noseY, 3, 2.5); // Left nostril\n        p.ellipse(2.5, 7 + noseY, 3, 2.5);  // Right nostril\n        break;\n    case 'long': // From V_User, adapted slightly\n        p.stroke(0); p.strokeWeight(1); p.noFill();\n        p.line(-2, -15 + noseY, -2, 13 + noseY); // Left bridge line\n        p.line(2, -15 + noseY, 2, 13 + noseY);  // Right bridge line\n        p.arc(0, 13 + noseY, 15, 10, 0, p.PI);  // Bottom curve of nose\n        p.fill(noseShadowColor); p.noStroke();\n        p.ellipse(-4, 12 + noseY, 4, 3); // Left nostril\n        p.ellipse(4, 12 + noseY, 4, 3);  // Right nostril\n        break;\n    default: p.stroke(0); p.strokeWeight(2); p.noFill(); p.line(0, -10 + noseY, 0, 10 + noseY); p.arc(0, 10 + noseY, 15, 10, 0, p.PI);\n  }\n  p.strokeWeight(2); // Reset default stroke weight for other functions\n}\n\nfunction drawEyebrows() { // Retained from V_Mine\n  let hairColor = getHairColor(faceParams.hair_color);\n  p.fill(hairColor); p.noStroke();\n  let browY = -42; let browSpacing = 28; let browLength = 22;\n  let browHeightOuter = 5; let browHeightInner = 4;\n  function drawOneBrow(side) {\n    p.beginShape(); p.vertex(side * (browSpacing - browLength / 2), browY + browHeightInner / 2);\n    p.bezierVertex(side*(browSpacing - browLength/4), browY - browHeightOuter, side*(browSpacing + browLength/4), browY - browHeightOuter * (faceParams.eyebrow_style === 'arched' ? 1.2 : 0.8), side*(browSpacing + browLength/2), browY);\n    p.bezierVertex(side*(browSpacing + browLength/3), browY + browHeightOuter*0.3, side*(browSpacing - browLength/3), browY + browHeightInner*0.6, side*(browSpacing - browLength/2), browY + browHeightInner/2);\n    p.endShape(p.CLOSE);\n  }\n  // V_User bushy style\n  if (faceParams.eyebrow_style === 'bushy') {\n      p.stroke(hairColor); // Use stroke for bushy, no fill\n      p.noFill();\n      for(let side of [-1, 1]) {\n          for(let i = 0; i < 7; i++) {\n            p.strokeWeight(p.random(1, 2.5));\n            let x1 = side * (browSpacing - browLength / 2 + p.random(-3,3));\n            let y1 = browY + p.random(-3,3);\n            let x2 = side * (browSpacing + browLength / 2 + p.random(-3,3));\n            let y2 = browY + p.random(-3,3);\n            let cp1x = side * (browSpacing - browLength / 4 + p.random(-3,3));\n            let cp1y = browY - browHeightOuter * 1.2 + p.random(-3,3);\n            let cp2x = side * (browSpacing + browLength / 4 + p.random(-3,3));\n            let cp2y = browY - browHeightOuter * 1.2 + p.random(-3,3);\n            p.bezier(x1,y1, cp1x, cp1y, cp2x, cp2y, x2, y2);\n          }\n      }\n      p.noStroke(); // Reset\n  } else if (faceParams.eyebrow_style === 'angled') { // V_User angled style\n      p.stroke(hairColor); p.strokeWeight(3); p.noFill();\n      let angSpacing = browSpacing - 2;\n      let angLen = browLength * 0.5;\n      p.line(-angSpacing - angLen, browY + 3, -angSpacing, browY - 2);\n      p.line(-angSpacing, browY - 2, -angSpacing + angLen, browY);\n      p.line(angSpacing - angLen, browY, angSpacing, browY - 2);\n      p.line(angSpacing, browY - 2, angSpacing + angLen, browY + 3);\n      p.noStroke(); // Reset\n  }\n  else { // V_Mine other styles\n    switch(faceParams.eyebrow_style) {\n        case 'arched': case 'straight': browHeightOuter = faceParams.eyebrow_style === 'straight' ? 4 : 6; drawOneBrow(-1); drawOneBrow(1); break;\n        case 'thick': browHeightOuter = 8; browHeightInner = 7; drawOneBrow(-1); drawOneBrow(1); break;\n        case 'thin': browHeightOuter = 3; browHeightInner = 2.5; drawOneBrow(-1); drawOneBrow(1); break;\n        default: p.stroke(hairColor); p.strokeWeight(3); p.noFill(); p.arc(-browSpacing, browY, 20, 10, p.PI, p.TWO_PI); p.arc(browSpacing, browY, 20, 10, p.PI, p.TWO_PI); p.noStroke();\n    }\n  }\n}\n\n\n// --- Borrowed/Merged Drawing Functions ---\nfunction drawEars() { // Borrowed from V_User\n  if (faceParams.ear_size === 'hidden') return;\n  let earSizeMap = {'tiny': 15, 'small': 20, 'medium': 25, 'large': 30, 'prominent': 35};\n  let size = earSizeMap[faceParams.ear_size] || 25;\n  let earY = 0; let earX = 80; // V_User fixed X\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  let shadowColor = p.lerpColor(skinColor, p.color(0), 0.08); // V_User uses a subtle shadow\n  let detailColor = p.lerpColor(skinColor, p.color(0), 0.15);\n\n  function drawOneEar(side) {\n    p.push();\n    p.translate(side * earX, earY);\n    // Ear shadow (subtle, behind ear)\n    p.noStroke(); p.fill(shadowColor);\n    p.ellipse(side * 2, 2, size, size * 1.3);\n    // Main ear\n    p.fill(skinColor); p.stroke(detailColor); p.strokeWeight(1);\n    p.ellipse(0, 0, size, size * 1.3);\n    // Inner ear detail (from V_User)\n    p.noFill(); p.stroke(detailColor); p.strokeWeight(0.8);\n    p.arc(0, 0, size * 0.6, size * 0.8, side === 1 ? p.PI * 0.5 : -p.PI * 0.5, side === 1 ? p.PI * 1.5 : p.PI * 0.5);\n    p.arc(side * size * 0.1, -size * 0.2, size * 0.4, size * 0.4, p.PI * 0.2, p.PI * 0.8);\n    p.pop();\n  }\n  drawOneEar(-1); // Left\n  drawOneEar(1);  // Right\n}\n\nfunction drawEyes() { // Borrowed from V_User\n  let eyeColor = getEyeColor(faceParams.eye_color);\n  let eyeSpacing = 25; let eyeY = -25;\n  p.push(); p.translate(-eyeSpacing, eyeY); drawEye(eyeColor); p.pop();\n  p.push(); p.translate(eyeSpacing, eyeY); drawEye(eyeColor); p.pop();\n}\n\nfunction drawEye(eyeColor) { // Borrowed from V_User\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  let socketShadow = p.lerpColor(skinColor, p.color(0), 0.05);\n  let eyelidLineColor = p.lerpColor(skinColor, p.color(0), 0.3);\n\n  p.push(); p.noStroke(); p.fill(socketShadow); p.ellipse(1, 1, 30, 22); p.pop(); // Eye socket\n  p.push(); p.stroke(eyelidLineColor); p.strokeWeight(0.5); p.fill(253, 253, 250); // Sclera\n  switch(faceParams.eye_shape) {\n    case 'almond':\n      p.beginShape(); p.vertex(-12.5, 0);\n      p.bezierVertex(-12.5, -6, -6, -7, 0, -7); p.bezierVertex(6, -7, 12.5, -6, 12.5, 0);\n      p.bezierVertex(12.5, 6, 6, 7, 0, 7); p.bezierVertex(-6, 7, -12.5, 6, -12.5, 0);\n      p.endShape(p.CLOSE); break;\n    case 'round': p.ellipse(0, 0, 20, 20); break; // V_User used circle, I'll use ellipse for consistency\n    case 'hooded': // V_User's simpler hooded\n      p.arc(0, 0, 25, 18, 0.1, p.PI - 0.1, p.CHORD); // Upper part\n      p.beginShape(); // Lower lid line visible\n      p.vertex(-12.5, 0); p.bezierVertex(-6, 5, 6, 5, 12.5, 0); p.endShape();\n      // Hood shadow\n      p.fill(socketShadow); p.noStroke();\n      p.arc(0, -3, 26, 12, p.PI-0.1, p.TWO_PI+0.1);\n      break;\n    case 'narrow': p.ellipse(0, 0, 27.5, 10); break;\n    case 'wide': p.ellipse(0, 0, 22.5, 20); break;\n    case 'upturned': p.push(); p.rotate(-0.15); p.ellipse(0, 0, 25, 14); p.pop(); break;\n    default: p.ellipse(0,0,25,15); // Fallback\n  }\n  p.pop();\n  p.push(); p.noStroke(); // Iris with gradient\n  for(let i = 10; i > 0; i--) {\n    let alpha = p.map(i, 0, 10, 255, 150); let size = p.map(i, 0, 10, 10, 5);\n    p.fill(p.red(eyeColor), p.green(eyeColor), p.blue(eyeColor), alpha); p.circle(0, 0, size);\n  }\n  p.pop();\n  p.fill(0); p.circle(0, 0, 3.5); // Pupil\n  p.fill(255, 255, 255, 200); p.circle(1.5, -1.5, 2); // Main Highlight\n  p.fill(255, 255, 255, 100); p.circle(0.8, -2.2, 1.2); // Secondary Highlight\n  \n  // Eyelid line (V_User style)\n  p.stroke(eyelidLineColor); p.strokeWeight(0.75); p.noFill();\n  if (faceParams.eye_shape !== 'hooded') {\n    p.arc(0, -3.5, 25, 10, p.PI+0.1, p.TWO_PI-0.1); // Upper eyelid crease\n  }\n}\n\nfunction drawMouth() { // Borrowed from V_User\n  p.push();\n  let mouthY = 40;\n  let skinColor = getSkinColor(faceParams.skin_tone);\n  let lipColor = p.lerpColor(skinColor, p.color(200, 100, 110), 0.4);\n  let mouthLineColor = p.lerpColor(lipColor, p.color(0), 0.3);\n  p.noStroke(); p.fill(p.lerpColor(skinColor, p.color(0),0.06)); p.ellipse(1, mouthY + 2, 42, 17); // Mouth shadow\n  p.stroke(mouthLineColor); p.strokeWeight(0.8); p.fill(lipColor);\n  switch(faceParams.mouth_shape) {\n    case 'full':\n      p.beginShape(); p.vertex(-20, mouthY); p.bezierVertex(-20, mouthY - 4, -10, mouthY - 6, 0, mouthY - 3);\n      p.bezierVertex(10, mouthY - 6, 20, mouthY - 4, 20, mouthY); p.endShape(); // Upper top\n      p.beginShape(); p.vertex(-20, mouthY); p.bezierVertex(-15, mouthY + 4, -10, mouthY + 8, 0, mouthY + 8);\n      p.bezierVertex(10, mouthY + 8, 15, mouthY + 4, 20, mouthY); p.endShape(); // Lower bottom\n      p.strokeWeight(1); p.line(-18, mouthY, 18, mouthY); // Center line\n      break;\n    case 'thin':\n      p.strokeWeight(1); // Thinner lips, slightly stronger line\n      p.beginShape(); p.vertex(-17.5, mouthY); p.bezierVertex(-15, mouthY - 2, -7.5, mouthY - 3, 0, mouthY - 1.5);\n      p.bezierVertex(7.5, mouthY - 3, 15, mouthY - 2, 17.5, mouthY); p.endShape();\n      p.beginShape(); p.vertex(-17.5, mouthY); p.bezierVertex(-15, mouthY + 2, -7.5, mouthY + 3, 0, mouthY + 1.5);\n      p.bezierVertex(7.5, mouthY + 3, 15, mouthY + 2, 17.5, mouthY); p.endShape();\n      p.strokeWeight(1.2); p.line(-16, mouthY, 16, mouthY);\n      break;\n    case 'wide':\n      p.beginShape(); p.vertex(-25, mouthY); p.bezierVertex(-25, mouthY - 3, -12.5, mouthY - 5, 0, mouthY - 2.5);\n      p.bezierVertex(12.5, mouthY - 5, 25, mouthY - 3, 25, mouthY); p.endShape();\n      p.beginShape(); p.vertex(-25, mouthY); p.bezierVertex(-20, mouthY + 3, -10, mouthY + 5, 0, mouthY + 5);\n      p.bezierVertex(10, mouthY + 5, 20, mouthY + 3, 25, mouthY); p.endShape();\n      p.strokeWeight(1); p.line(-23, mouthY, 23, mouthY);\n      break;\n    case 'small':\n      p.beginShape(); p.vertex(-12.5, mouthY); p.bezierVertex(-12.5, mouthY - 3, -6, mouthY - 4, 0, mouthY - 2.5);\n      p.bezierVertex(6, mouthY - 4, 12.5, mouthY - 3, 12.5, mouthY); p.endShape();\n      p.beginShape(); p.vertex(-12.5, mouthY); p.bezierVertex(-10, mouthY + 3, -5, mouthY + 4, 0, mouthY + 4);\n      p.bezierVertex(5, mouthY + 4, 10, mouthY + 3, 12.5, mouthY); p.endShape();\n      p.strokeWeight(1); p.line(-11, mouthY, 11, mouthY);\n      break;\n    case 'heart':\n      p.beginShape(); p.vertex(-15, mouthY); p.bezierVertex(-15, mouthY - 5, -10, mouthY - 7, -5, mouthY - 7);\n      p.bezierVertex(-2.5, mouthY - 7, -1, mouthY - 5, 0, mouthY - 3);\n      p.bezierVertex(1, mouthY - 5, 2.5, mouthY - 7, 5, mouthY - 7);\n      p.bezierVertex(10, mouthY - 7, 15, mouthY - 5, 15, mouthY);p.endShape();\n      p.beginShape(); p.vertex(-15, mouthY); p.bezierVertex(-12, mouthY + 5, -6, mouthY + 8, 0, mouthY + 8);\n      p.bezierVertex(6, mouthY + 8, 12, mouthY + 5, 15, mouthY);p.endShape();\n      p.strokeWeight(1); p.line(-13, mouthY, 13, mouthY);\n      break;\n    case 'curved':\n      p.noFill(); p.stroke(mouthLineColor); p.strokeWeight(1.5); p.beginShape(); p.vertex(-20, mouthY - 2);\n      p.bezierVertex(-15, mouthY + 3, -5, mouthY + 5, 0, mouthY + 4); // Adjusted smile curve\n      p.bezierVertex(5, mouthY + 5, 15, mouthY + 3, 20, mouthY - 2); p.endShape();\n      break;\n    default: p.ellipse(0, mouthY, 35,12); p.line(-15, mouthY, 15, mouthY); // Fallback\n  }\n  p.pop();\n}\n\nfunction drawHairBack() { // Merged: V_User for most, specific V_Mine handling if any\n  if (faceParams.hair_style === 'bald') return;\n  p.push();\n  p.fill(getHairColor(faceParams.hair_color));\n  p.noStroke(); // V_User hair often noStroke for back\n  switch(faceParams.hair_style) {\n    case 'short': /* V_Mine short hair usually doesn't need back, or it's part of front */ break;\n    // Styles from V_User\n    case 'long':\n      p.beginShape(); p.vertex(-85, -70); p.bezierVertex(-90, -50, -88, -20, -87, 20);\n      p.bezierVertex(-88, 60, -85, 100, -80, 140); p.vertex(-75, 160); p.vertex(75, 160);\n      p.vertex(80, 140); p.bezierVertex(85, 100, 88, 60, 87, 20);\n      p.bezierVertex(88, -20, 90, -50, 85, -70); p.bezierVertex(60, -95, -60, -95, -85, -70);\n      p.endShape(p.CLOSE); break;\n    case 'wavy':\n      p.beginShape(); p.vertex(-80, -75);\n      for(let y = -75; y <= 100; y += 20) { let xO = p.sin(y*0.1)*5; p.bezierVertex(-85+xO, y-10, -83+xO, y+10, -82+xO, y+20); }\n      p.vertex(-80, 100); p.vertex(80, 100);\n      for(let y = 100; y >= -75; y -= 20) { let xO = p.sin(y*0.1)*5; p.bezierVertex(83+xO, y+10, 85+xO, y-10, 82+xO, y-20); }\n      p.vertex(80, -75); p.bezierVertex(50, -100, -50, -100, -80, -75);\n      p.endShape(p.CLOSE); break;\n    case 'curly':\n      let basePos = [ {x:-70,y:-80},{x:-60,y:-90},{x:-40,y:-95},{x:-20,y:-98},{x:0,y:-100},{x:20,y:-98},\n                      {x:40,y:-95},{x:60,y:-90},{x:70,y:-80},{x:-75,y:-40},{x:75,y:-40},{x:-80,y:0},\n                      {x:80,y:0},{x:-82,y:40},{x:82,y:40} ];\n      for(let pos of basePos) { for(let i=0;i<3;i++) { p.circle(pos.x+p.random(-15,15), pos.y+p.random(-15,15), p.random(25,45)); }}\n      break;\n    case 'straight':\n      p.beginShape(); p.vertex(-80, -85); p.vertex(-82, 120); p.vertex(-78, 140);\n      p.vertex(78, 140); p.vertex(82, 120); p.vertex(80, -85);\n      p.bezierVertex(50, -100, -50, -100, -80, -85); p.endShape(p.CLOSE); break;\n    default: // Fallback if needed (e.g., from V_Mine if it had one)\n      p.rect(0, 75, 165, 150, 0, 0, 50, 50); // Original V_Mine Long hair back\n  }\n  p.pop();\n}\n\nfunction drawHairFront() { // Merged: V_Mine for 'short', V_User for others\n  if (faceParams.hair_style === 'bald') return;\n  p.push();\n  p.fill(getHairColor(faceParams.hair_color));\n  p.stroke(p.lerpColor(getHairColor(faceParams.hair_color), p.color(0), 0.2)); // Unified stroke for hair\n  p.strokeWeight(0.5); // V_User had 0.5, V_Mine had 1 for front hair. Let's try 0.5.\n\n  switch(faceParams.hair_style) {\n    case 'short': // Retained from V_Mine, adjusted stroke\n      p.beginShape(); p.vertex(-78, -98); p.bezierVertex(-85, -60, -80, -30, -75, -15);\n      p.bezierVertex(-60, -70, 0, -80, 75, -15); p.bezierVertex(80, -30, 85, -60, 78, -98);\n      p.bezierVertex(40, -110, -40, -110, -78, -98); p.endShape(p.CLOSE);\n      p.strokeWeight(0.3); // Texture lines from V_User's short\n      for(let i = 0; i < 10; i++) {\n        let x = p.random(-70, 70); let y1 = -80 + p.random(-5,5); let y2 = -65 + p.random(-5,5);\n        p.line(x, y1, x + p.random(-5, 5), y2);\n      }\n      break;\n    // Styles from V_User\n    case 'long':\n      p.beginShape(); p.vertex(-80, -75); p.bezierVertex(-85, -85, -70, -95, -50, -95);\n      p.bezierVertex(-30,-98,30,-98,50,-95); p.bezierVertex(70,-95,85,-85,80,-75);\n      p.vertex(80,-60); p.bezierVertex(60,-65,40,-70,20,-68);\n      p.bezierVertex(0,-67,-20,-65,-40,-60); p.bezierVertex(-60,-58,-75,-60,-80,-60);\n      p.endShape(p.CLOSE); break;\n    case 'wavy':\n      p.beginShape(); p.vertex(-80, -75);\n      for(let x=-80; x<=80; x+=20){ let y=-90+p.sin(x*0.1)*8; p.bezierVertex(x-10,y-5,x+10,y+5,x+20,y); }\n      p.vertex(80,-75); p.vertex(80,-60); p.bezierVertex(70,-65,60,-68,40,-65);\n      p.bezierVertex(20,-63,0,-65,-20,-63); p.bezierVertex(-40,-65,-60,-63,-80,-60);\n      p.endShape(p.CLOSE); break;\n    case 'curly':\n      let curlPos = [ {x:-60,y:-85},{x:-40,y:-90},{x:-20,y:-93},{x:0,y:-95},{x:20,y:-93},{x:40,y:-90},\n                      {x:60,y:-85},{x:-70,y:-70},{x:70,y:-70},{x:-50,y:-65},{x:50,y:-65},{x:0,y:-70} ];\n      p.noStroke(); // V_User curly has no stroke for front curls\n      for(let pos of curlPos) { p.circle(pos.x+p.random(-5,5), pos.y+p.random(-5,5), p.random(20,35)); }\n      break;\n    case 'straight':\n      p.beginShape(); p.vertex(-80, -85); p.bezierVertex(-75,-95,-50,-100,0,-100);\n      p.bezierVertex(50,-100,75,-95,80,-85); p.vertex(80,-65); p.vertex(60,-70);\n      p.vertex(60,-75); p.vertex(-60,-75); p.vertex(-60,-70); p.vertex(-80,-65);\n      p.endShape(p.CLOSE); break;\n    default: p.fill(getHairColor(faceParams.hair_color)); p.arc(0, -25, 160, 150, p.PI, p.TWO_PI); // Fallback\n  }\n  p.pop();\n}\n\nfunction drawFacialHair() { // Borrowed from V_User, full-beard modified\n  if (faceParams.facial_hair === 'none') return;\n  p.push();\n  let hairC = getHairColor(faceParams.hair_color);\n  p.fill(hairC); p.stroke(p.lerpColor(hairC, p.color(0), 0.3)); // Slightly darker stroke\n  switch(faceParams.facial_hair) {\n    case 'mustache':\n      p.strokeWeight(0.5); p.beginShape(); p.vertex(-25, 25);\n      p.bezierVertex(-20,20,-10,18,0,20); p.bezierVertex(10,18,20,20,25,25);\n      p.bezierVertex(22,30,15,32,0,30); p.bezierVertex(-15,32,-22,30,-25,25);\n      p.endShape(p.CLOSE);\n      p.noFill();\n      for(let i=0;i<15;i++){let x=p.random(-20,20);let y=p.random(22,28);p.strokeWeight(0.3);p.line(x,y,x+p.random(-2,2),y+2);}\n      break;\n    case 'goatee': // V_User's Goatee\n      p.strokeWeight(1); p.arc(0, 25, 40, 15, 0, p.PI); // Mustache part\n      p.beginShape(); p.vertex(-15, 50); p.bezierVertex(-18,55,-18,65,-15,70); // Chin part\n      p.bezierVertex(-10,75,10,75,15,70); p.bezierVertex(18,65,18,55,15,50);\n      p.bezierVertex(10,48,-10,48,-15,50); p.endShape(p.CLOSE);\n      break;\n    case 'full-beard': // Modified V_User's full-beard\n      p.strokeWeight(1); p.fill(hairC);\n      p.beginShape();\n      let beardTopY = 18; // Start slightly higher\n      let sideburnTopX = 65; // More connected to potential sideburn area\n      let jawOuterX = 55;\n      let jawOuterY = 65; // Less low on Y\n      let chinBottomY = 80; // Raised chin point\n\n      p.vertex(-sideburnTopX, beardTopY); // Start top-left (near sideburn)\n      p.bezierVertex(-jawOuterX-5, beardTopY + 15, -jawOuterX, jawOuterY -10, -jawOuterX +5, jawOuterY); // Upper jaw curve left\n      p.bezierVertex(-jawOuterX, jawOuterY + 10, -30, chinBottomY +5, 0, chinBottomY);   // Lower jaw to chin left\n      p.bezierVertex(30, chinBottomY + 5, jawOuterX, jawOuterY + 10, jawOuterX -5, jawOuterY);    // Chin to lower jaw right\n      p.bezierVertex(jawOuterX, jawOuterY -10, jawOuterX+5, beardTopY + 15, sideburnTopX, beardTopY);    // Upper jaw curve right\n      // Top edge (mustache area)\n      p.bezierVertex(sideburnTopX * 0.6, beardTopY -5, 0, beardTopY-2, -sideburnTopX * 0.6, beardTopY-5);\n      p.endShape(p.CLOSE);\n      // Texture (from V_User)\n      p.noFill(); p.stroke(p.lerpColor(hairC, p.color(0), 0.5));\n      for(let i=0;i<30;i++){let x=p.random(-jawOuterX+10,jawOuterX-10);let y=p.random(beardTopY+5,chinBottomY-5);\n        if(p.dist(x,y,0, (beardTopY+chinBottomY)/2) < jawOuterX*0.8){p.strokeWeight(p.random(0.5,1));p.arc(x,y,p.random(5,10),p.random(5,12),p.random(p.TWO_PI),p.random(p.TWO_PI));}\n      }\n      break;\n    case 'stubble': // V_User's Stubble\n      p.strokeWeight(0.8); p.noFill(); p.stroke(hairC);\n      for(let i=0;i<200;i++){let x=p.random(-50,50);let y=p.random(20,80);\n        if(y<40&&p.abs(x)<25){p.point(x,y);} else if(y>=40&&p.dist(x,y,0,55)<45){p.point(x,y);}}\n      break;\n    case 'sideburns': // V_User's Sideburns\n      p.strokeWeight(1); p.fill(hairC);\n      for(let side of [-1,1]) {\n        p.beginShape(); p.vertex(side*75,-10); p.bezierVertex(side*78,0,side*78,30,side*75,50);\n        p.bezierVertex(side*72,55,side*68,58,side*65,55); p.vertex(side*65,30);p.vertex(side*65,-10);\n        p.endShape(p.CLOSE);\n        p.noFill(); p.stroke(p.lerpColor(hairC, p.color(0),0.4));\n        for(let i=0;i<10;i++){let x=side*70+p.random(-5,5);let y=p.random(-5,45);p.strokeWeight(0.3);p.line(x,y,x,y+5);}\n      }\n      break;\n    default: // Fallback\n      p.ellipse(0,30,40,20);\n  }\n  p.pop();\n}\n\nfunction drawAccessories() { // Borrowed from V_User\n  if (faceParams.accessories === 'none') return;\n  p.push();\n  if (faceParams.accessories.includes('glasses') || faceParams.accessories === 'glasses') {\n    p.stroke(40); p.strokeWeight(2.5); p.noFill(); // Slightly thicker frames\n    p.rect(-28, -25, 42, 32, 8); p.rect(28, -25, 42, 32, 8); // Lenses\n    p.strokeWeight(2); p.arc(0,-23,10,5,0,p.PI); // Bridge\n    p.line(-49,-25,-75,-30); p.line(49,-25,75,-30); // Arms\n  }\n  if (faceParams.accessories.includes('sunglasses') || faceParams.accessories === 'sunglasses') {\n    p.stroke(20); p.strokeWeight(3.5); p.fill(20,20,30,200); // Slightly thicker\n    p.rect(-28, -25, 42, 32, 8); p.rect(28, -25, 42, 32, 8);\n    p.strokeWeight(2.5); p.noFill(); p.arc(0,-23,10,5,0,p.PI);\n    p.strokeWeight(3.5); p.fill(20,20,30,200); // Arms also filled/thick\n    p.line(-49,-25,-75,-30); p.line(49,-25,75,-30);\n  }\n  if (faceParams.accessories.includes('earrings') || faceParams.accessories === 'earrings') {\n    p.noStroke(); p.fill(255,215,0);\n    let earOffset = faceParams.ear_size === 'hidden' ? 70 : 80; // Closer if ears hidden\n    let earlobeY = faceParams.ear_size === 'hidden' ? 5 : 15;\n    p.push();p.translate(-earOffset,earlobeY);p.circle(0,0,6);p.triangle(-3,3,3,3,0,12);p.pop();\n    p.push();p.translate(earOffset,earlobeY);p.circle(0,0,6);p.triangle(-3,3,3,3,0,12);p.pop();\n  }\n  if (faceParams.accessories === 'hat') {\n    p.fill(50,45,40); p.stroke(30,25,20); p.strokeWeight(1.5); // Darker hat\n    p.beginShape(); p.vertex(-60,-100); p.bezierVertex(-60,-115,-40,-120,0,-120); // Crown top\n    p.bezierVertex(40,-120,60,-115,60,-100); p.vertex(60,-85);p.vertex(-60,-85);p.endShape(p.CLOSE);\n    p.ellipse(0,-85,180,25); // Brim\n    p.fill(75,70,65); p.rect(0,-92,120,10,3); // Band, slightly higher\n  }\n  p.pop();\n}\n\n// --- Control and Utility Functions (from V_Mine) ---\nfunction randomizeFace() {\n  for (let trait in traitOptions) {\n    faceParams[trait] = traitOptions[trait][Math.floor(Math.random() * traitOptions[trait].length)];\n  }\n}\np.pauseAnimation = function() { isPaused = true; console.log(\"Animation paused\"); };\np.resumeAnimation = function() { isPaused = false; console.log(\"Animation resumed\"); };\np.setTrait = function(traitName, descriptorValue) {\n  if (traitOptions[traitName] && traitOptions[traitName].includes(descriptorValue)) {\n    faceParams[traitName] = descriptorValue; console.log(`Set ${traitName} to ${descriptorValue}`);\n    if(isPaused) p.redraw(); \n  } else { console.error(`Invalid trait or value: ${traitName} = ${descriptorValue}`); }\n};"
  }
}