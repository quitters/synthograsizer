{
  "promptTemplate": "A Game of Life simulation with cell size {{cell_size}}, birth rule {{birth_rule}}, survival range {{survive_lower}}-{{survive_upper}}, color scheme {{color_scheme}}.",
  "variables": [
    { "name": "Cell Size", "feature_name": "cell_size", "values": ["5", "10", "15", "20"] },
    { "name": "Birth Rule", "feature_name": "birth_rule", "values": ["2", "3", "4"] },
    { "name": "Survive Lower", "feature_name": "survive_lower", "values": ["1", "2", "3"] },
    { "name": "Survive Upper", "feature_name": "survive_upper", "values": ["3", "4", "5"] },
    { "name": "Color Scheme", "feature_name": "color_scheme", "values": ["classic", "heatmap", "neon", "grayscale"] }
  ],
  "p5_input": {
    "code": "// SYNTHOGRASIZER P5.JS EXAMPLE: Conway's Game of Life\n// \n// This example implements Conway's Game of Life cellular automaton\n// with interactive controls for adjusting rules and visualization.\n// It demonstrates:\n// - Grid-based cellular automata\n// - Dynamic rule adjustments through variables\n// - Generative pattern creation\n// - Color mapping strategies\n//\n// REQUIRED VARIABLES:\n// - \"cell_size\" for grid resolution (5-20)\n// - \"birth_rule\" for number of neighbors to create a cell (typically 3)\n// - \"survive_lower\" for min neighbors to survive (typically 2)\n// - \"survive_upper\" for max neighbors to survive (typically 3)\n// - \"color_scheme\" for different visualization modes\n\n// Grid parameters\nlet grid = [];\nlet nextGrid = [];\nlet cols, rows;\nlet paused = false;\nlet generation = 0;\nlet population = 0;\n\n// Rules (classic Game of Life by default)\nlet birthRule = 3;\nlet surviveLowerBound = 2;\nlet surviveUpperBound = 3;\n\n// Performance-related\nlet lastUpdateTime = 0;\nlet updateInterval = 100; // milliseconds between updates\nlet frameRateValue = 0;\n\n// Visualization\nlet cellColorScheme = 'classic';\nlet showGrid = true;\n\np.setup = function() {\n  p.createCanvas(500, 400).parent(p5Output);\n  p.frameRate(30);\n  \n  // Initialize with a reasonable cell size\n  initializeGrid(10);\n  \n  // Add some random cells to start with\n  randomizeGrid(0.3); // 30% chance of alive cells\n  \n  p.print(\"Game of Life initialized!\");\n  p.print(\"Use the Synthograsizer variables to control the simulation.\");\n  p.print(\"- cell_size: Controls grid resolution\");\n  p.print(\"- birth_rule: Number of neighbors needed for birth\");\n  p.print(\"- survive_lower: Minimum neighbors for survival\");\n  p.print(\"- survive_upper: Maximum neighbors for survival\");\n  p.print(\"- color_scheme: Visualization style\");\n};\n\np.draw = function() {\n  // Get variables from Synthograsizer\n  const cellSizeVar = p.getSynthVar('cell_size') || 10;\n  const birthRuleVar = p.getSynthVar('birth_rule') || 3;\n  const surviveLowerVar = p.getSynthVar('survive_lower') || 2;\n  const surviveUpperVar = p.getSynthVar('survive_upper') || 3;\n  const colorSchemeVar = p.getSynthVar('color_scheme') || 'classic';\n  \n  // Process variables according to type\n  let cellSize = 10;\n  if (typeof cellSizeVar === 'number') {\n    cellSize = p.constrain(Math.floor(p.map(cellSizeVar, -1, 2, 5, 20)), 5, 20);\n  } else if (typeof cellSizeVar === 'string') {\n    cellSize = p.constrain(parseInt(cellSizeVar) || 10, 5, 20);\n  }\n  \n  // Parse other variables\n  birthRule = parseRuleValue(birthRuleVar, 3);\n  surviveLowerBound = parseRuleValue(surviveLowerVar, 2); \n  surviveUpperBound = parseRuleValue(surviveUpperVar, 3);\n  \n  // Validate rule bounds\n  surviveLowerBound = p.constrain(surviveLowerBound, 0, 8);\n  surviveUpperBound = p.constrain(surviveUpperBound, surviveLowerBound, 8);\n  \n  // Set color scheme\n  if (typeof colorSchemeVar === 'string') {\n    cellColorScheme = colorSchemeVar.toLowerCase();\n  }\n  \n  // Clear background - use dark gray for better contrast\n  p.background(32);\n  \n  // Check if we need to reinitialize the grid (cell size changed)\n  if (cellSize !== p.width / cols) {\n    initializeGrid(cellSize);\n    // Re-randomize if the grid is mostly empty\n    if (population / (cols * rows) < 0.1) {\n      randomizeGrid(0.3);\n    }\n  }\n  \n  // Calculate current frame rate\n  frameRateValue = p.frameRate();\n  \n  // Update the grid if not paused\n  if (!paused) {\n    updateGrid();\n    generation++;\n  }\n  \n  // Draw the grid and cells\n  drawGrid();\n  \n  // Display information overlay\n  displayInfo();\n};\n\n// Parse and constrain a rule value\nfunction parseRuleValue(value, defaultValue) {\n  if (typeof value === 'number') {\n    return Math.round(value);\n  } else if (typeof value === 'string') {\n    return parseInt(value) || defaultValue;\n  }\n  return defaultValue;\n}\n\n// Initialize the grid with given cell size\nfunction initializeGrid(cellSize) {\n  // Calculate grid dimensions based on cell size\n  cols = p.floor(p.width / cellSize);\n  rows = p.floor(p.height / cellSize);\n  \n  // Initialize grid with zeros\n  for (let i = 0; i < rows; i++) {\n    grid[i] = [];\n    nextGrid[i] = [];\n    for (let j = 0; j < cols; j++) {\n      grid[i][j] = 0;\n      nextGrid[i][j] = 0;\n    }\n  }\n  \n  // Reset population counter\n  population = 0;\n}\n\n// Fill grid with random living cells\nfunction randomizeGrid(density) {\n  // Randomly set cells to alive (1) or dead (0)\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (p.random(1) < density) {\n        grid[i][j] = 1;\n        population++;\n      }\n    }\n  }\n}\n\n// Update the grid according to the Game of Life rules\nfunction updateGrid() {\n  // Iterate over each cell in the grid\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      // Count living neighbors\n      let neighbors = countNeighbors(i, j);\n      \n      // Apply Game of Life rules\n      if (grid[i][j] === 1 && (neighbors < surviveLowerBound || neighbors > surviveUpperBound)) {\n        nextGrid[i][j] = 0; // Underpopulation or overpopulation: die\n      } else if (grid[i][j] === 0 && neighbors === birthRule) {\n        nextGrid[i][j] = 1; // Reproduction: new cell born\n      } else {\n        nextGrid[i][j] = grid[i][j]; // Stagnation: no change\n      }\n    }\n  }\n  \n  // Swap current and next grids\n  [grid, nextGrid] = [nextGrid, grid];\n}\n\n// Count living neighbors around a cell\nfunction countNeighbors(x, y) {\n  let neighbors = 0;\n  \n  // Check all eight neighboring cells\n  for (let i = -1; i <= 1; i++) {\n    for (let j = -1; j <= 1; j++) {\n      // Skip the cell itself\n      if (i === 0 && j === 0) continue;\n      \n      // Calculate neighbor's coordinates, wrapping around edges\n      let col = (x + i + cols) % cols;\n      let row = (y + j + rows) % rows;\n      \n      // If neighbor is alive, increment count\n      if (grid[row][col] === 1) neighbors++;\n    }\n  }\n  \n  return neighbors;\n}\n\n// Draw the grid and cells\nfunction drawGrid() {\n  // Draw grid lines (optional)\n  if (showGrid) {\n    p.stroke(64);\n    for (let i = 0; i < rows; i++) {\n      p.line(0, i * p.width / rows, p.width, i * p.width / rows);\n    }\n    for (let j = 0; j < cols; j++) {\n      p.line(j * p.height / cols, 0, j * p.height / cols, p.height);\n    }\n  }\n  \n  // Draw cells\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) {\n        // Set color based on chosen color scheme\n        setColorByScheme(cellColorScheme, countNeighbors(i, j));\n        \n        // Draw cell as a rectangle\n        p.noStroke();\n        p.rect(j * p.width / cols, i * p.height / rows, p.width / cols, p.height / rows);\n      }\n    }\n  }\n}\n\n// Set color based on chosen color scheme\nfunction setColorByScheme(scheme, neighbors) {\n  switch (scheme) {\n    case 'classic':\n      p.fill(255); // White for alive cells\n      break;\n    case 'heatmap':\n      p.fill(p.map(neighbors, 0, 8, 0, 255), 255, 255); // Heatmap based on neighbors\n      break;\n    case 'neon':\n      p.fill(0, 255, 0); // Green for alive cells\n      break;\n    case 'grayscale':\n      p.fill(128 + neighbors * 16); // Grayscale based on neighbors\n      break;\n    default:\n      p.fill(255); // Default to white\n  }\n}\n\n// Display information overlay\nfunction displayInfo() {\n  // Display generation and population counts\n  p.fill(255);\n  p.noStroke();\n  p.textSize(12);\n  p.text(`Generation: ${generation}`, 10, 20);\n  p.text(`Population: ${population}`, 10, 40);\n  \n  // Display frame rate\n  p.text(`Frame Rate: ${frameRateValue.toFixed(2)} FPS`, 10, 60);\n}"
  }
}
